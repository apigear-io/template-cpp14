"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[78],{2807:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>u,contentTitle:()=>o,default:()=>h,frontMatter:()=>l,metadata:()=>p,toc:()=>c});var a=n(7462),i=(n(7294),n(3905)),r=n(814),s=n(7784);const l={sidebar_position:1},o="API Feature",p={unversionedId:"features/api",id:"features/api",title:"API Feature",description:"The feature api is the bare minimum for code generation. The feature will generate:",source:"@site/docs/features/api.md",sourceDirName:"features",slug:"/features/api",permalink:"/template-cpp14/features/api",draft:!1,editUrl:"https://github.com/apigear-io/template-cpp14/edit/main/docs/features/api.md",tags:[],version:"current",lastUpdatedBy:"dphan10",lastUpdatedAt:1706261464,formattedLastUpdatedAt:"Jan 26, 2024",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"docsSidebar",previous:{title:"Features",permalink:"/template-cpp14/features/"},next:{title:"Stubs",permalink:"/template-cpp14/features/stubs"}},u={},c=[{value:"Files overview per module",id:"files-overview-per-module",level:3},{value:"Enums and Structures",id:"enums-and-structures",level:3},{value:"Enums",id:"enums",level:4},{value:"Structs",id:"structs",level:4},{value:"Interfaces",id:"interfaces",level:3},{value:"Publisher",id:"publisher",level:4},{value:"Subscriber",id:"subscriber",level:4},{value:"Other",id:"other",level:3}],d={toc:c},m="wrapper";function h(e){let{components:t,...n}=e;return(0,i.kt)(m,(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"api-feature"},"API Feature"),(0,i.kt)("p",null,"The feature ",(0,i.kt)("inlineCode",{parentName:"p"},"api")," is the bare minimum for code generation. The feature will generate:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"core behavioral API for the defined ",(0,i.kt)("em",{parentName:"li"},"interfaces")),(0,i.kt)("li",{parentName:"ul"},"interfaces for ",(0,i.kt)("a",{parentName:"li",href:"api#publisher"},"publisher")," and ",(0,i.kt)("a",{parentName:"li",href:"api#subscriber"},"subscriber")," tailored for each interface"),(0,i.kt)("li",{parentName:"ul"},"Enumerations for the defined ",(0,i.kt)("em",{parentName:"li"},"enums")),(0,i.kt)("li",{parentName:"ul"},"Data structured with a core implementation for the defined ",(0,i.kt)("em",{parentName:"li"},"structs"))),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"Check out the ",(0,i.kt)("a",{parentName:"p",href:"/template-cpp14/features/stubs"},"stubs")," feature which provides fully functional implementation for the publisher.")),(0,i.kt)("h3",{id:"files-overview-per-module"},"Files overview per module"),(0,i.kt)("p",null,"Using the example API definition"),(0,i.kt)("details",null,(0,i.kt)("summary",null,"Hello World API (click to expand)"),(0,i.kt)(r.Z,{language:"yaml",showLineNumbers:!0,mdxType:"CodeBlock"},s.Z)),(0,i.kt)("p",null,"the following file structure will be generated inside the target folder. The purpose and content of each file is explained below."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"\ud83d\udcc2hello-world\n \u2523 \ud83d\udcc2apigear\n \u2523 \ud83d\udcc2cpp_hello_world\n \u2503 \u2523 \ud83d\udcc2apigear\n \u2503 \u2523 \ud83d\udcc2examples\n \u2503 \u2523 \ud83d\udcc2modules\n \u2503 \u2503   \u2517 \ud83d\udcc2io_world_module\n \u2503 \u2503      \u2517 \ud83d\udcc2io_world\n \u2503 \u2503         \u2523 \ud83d\udcc2generated\n \u2503 \u2503         \u2503  \u2523 \ud83d\udcc2api\n \u2503 \u2503         \u2503  \u2503  \u2523 \ud83d\udcdcCMakeLists.txt\n \u2503 \u2503         \u2503  \u2503  \u2523 \ud83d\udcdccommon.h\n \u2503 \u2503         \u2503  \u2503  \u2523 \ud83d\udcdcdatastructs.api.cpp\n \u2503 \u2503         \u2503  \u2503  \u2523 \ud83d\udcdcdatastructs.api.h\n \u2503 \u2503         \u2503  \u2503  \u2523 \ud83d\udcdchello.api.h\n \u2503 \u2503         \u2503  \u2503  \u2517 \ud83d\udcdcio_world.h\n .. .\n")),(0,i.kt)("h3",{id:"enums-and-structures"},"Enums and Structures"),(0,i.kt)("p",null,"Files ",(0,i.kt)("inlineCode",{parentName:"p"},"datastructs.api.h")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"datastructs.api.cpp")," contain core data structures and enumerations used in your module."),(0,i.kt)("h4",{id:"enums"},"Enums"),(0,i.kt)("p",null,"Inside the ",(0,i.kt)("inlineCode",{parentName:"p"},"datastructs.api.h")," you will find all the enums defined in your API. For each enum there is a ",(0,i.kt)("inlineCode",{parentName:"p"},"enum class")," generated with all the values defined."),(0,i.kt)("p",null,"For convenience of use each enum has a ",(0,i.kt)("inlineCode",{parentName:"p"},"toEnum")," function, which converts given ",(0,i.kt)("inlineCode",{parentName:"p"},"uint8_t")," to enum value."),(0,i.kt)("h4",{id:"structs"},"Structs"),(0,i.kt)("p",null,"All structs defined in your API are generated in ",(0,i.kt)("inlineCode",{parentName:"p"},"datastructs.api.h")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"datastructs.api.cpp")," files. They are used to communicate data between your API and its users."),(0,i.kt)("p",null,"For convenience of use each structure has:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"equality comparison operators"),(0,i.kt)("li",{parentName:"ul"},"empty constructor and a constructor with parameters for all its fields.")),(0,i.kt)("h3",{id:"interfaces"},"Interfaces"),(0,i.kt)("p",null,"For each interface inside an AP module there is separate file generated, like the ",(0,i.kt)("inlineCode",{parentName:"p"},"\ud83d\udcdchello.api.h"),"."),(0,i.kt)("p",null,"The interface class contains pure virtual functions as well as pure virtual subscriber and publisher classes."),(0,i.kt)("p",null,"The interface has:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"pure virtual ",(0,i.kt)("inlineCode",{parentName:"p"},"getters")," and a ",(0,i.kt)("inlineCode",{parentName:"p"},"setters")," for each property"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"virtual void setLast(const Message& last) = 0;\nvirtual const Message& getLast() const = 0;\n"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"pure virtual functions for each operation"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"virtual int say(const Message& msg, When::WhenEnum when) = 0;\n"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"and their asynchronous versions"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"virtual std::future<int> sayAsync(const Message& msg, WhenEnum when) = 0;\n"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"an access to a publisher"),(0,i.kt)("p",{parentName:"li"},"The interface does not contain signals defined in your interface, the signals feature is achieved with a subscriber/publisher mechanism."))),(0,i.kt)("p",null,"A class interested in notification on signal emission (and property changes) needs to use the publisher to subscribe for those events.\nThe important thing is that your implementation of the interface should notify the ",(0,i.kt)("inlineCode",{parentName:"p"},"IHelloPublisher")," about emitted signals or state changed."),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"Notice the convention for the getter - we use an underscore ",(0,i.kt)("inlineCode",{parentName:"p"},"_")," - this function is added by the generator to your interface. The underscore is used to prevent name collision with your implementation of the interface."),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"virtual IHelloPublisher& _getPublisher() const = 0;\n"))),(0,i.kt)("h4",{id:"publisher"},"Publisher"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"IHelloPublisher")," provides the interface for subscribing and unsubscribing from a signal emission\nor a property change. Use of such a class is mandatory for implementation and allows users of your API to react on changes."),(0,i.kt)("p",null,"The publisher is responsible for keeping its clients informed about requested changes. But it is the interface (here ",(0,i.kt)("inlineCode",{parentName:"p"},"IHello"),") implementation responsibility\nto call the publish functions from its API when signal or property change occurs e.g:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp",metastring:"IHello implementation",IHello:!0,implementation:!0},"void Hello::setLast(const Message& last)\n{\n    ...\n    // call the publish function\n    m_publisher->publishLastChanged(last);\n\n}\n")),(0,i.kt)("p",null,"There are two ways of subscribing for changes."),(0,i.kt)("p",null,"Either provide an implementation for ",(0,i.kt)("inlineCode",{parentName:"p"},"ISubscriber")," interface class and use is with those publisher's functions"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"void subscribeToAllChanges(IHelloSubscriber& subscriber);\nvoid unsubscribeFromAllChanges(IHelloSubscriber& subscriber);\n")),(0,i.kt)("p",null,"The subscribe ISubscriber assures your subscriber will be informed about all emitted signals and all property changes."),(0,i.kt)("p",null,"The other option is to use the ",(0,i.kt)("em",{parentName:"p"},"parallel")," system of notification which doesn't require the ",(0,i.kt)("inlineCode",{parentName:"p"},"ISubscriber")," and informs your Interface user about change of specific property or signal emission. E.g for ",(0,i.kt)("inlineCode",{parentName:"p"},"LastChanged")," property we have:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"long subscribeToLastChanged(HelloLastPropertyCb callback); // returns handleId that needs to be used to unsubscribe\nvoid unsubscribeFromLastChanged(long handleId);\n")),(0,i.kt)("p",null,"The publisher will execute the provided callback function each time and only when this property is changed."),(0,i.kt)("admonition",{type:"caution"},(0,i.kt)("p",{parentName:"admonition"},"For both methods of subscribing make sure to remove subscription for a ISubscriber/callback before it becomes invalid.\nAlso make sure that the subscribed function is not blocking and returns immediately!")),(0,i.kt)("p",null,"The publish functions need to be called by the implementation of the ",(0,i.kt)("inlineCode",{parentName:"p"},"IHello")," on each property change or signal emission to notify all the subscribers about this change."),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"Subscriptions systems are parallel - if you use both of them for single interface user i.e subscribe your class as an ",(0,i.kt)("inlineCode",{parentName:"p"},"ISubscriber")," and for a single change\nyour subscriber will be informed twice about that change, one for each subscription mechanism."),(0,i.kt)("p",{parentName:"admonition"},"This means that the unsubscribe functions for both mechanisms work only for that mechanism, i.e. the unsubscribe with ",(0,i.kt)("inlineCode",{parentName:"p"},"ISubscriber")," will not remove any subscriptions for the specific property/signal and they stay intact.")),(0,i.kt)("h4",{id:"subscriber"},"Subscriber"),(0,i.kt)("p",null,"For each interface we generate the ",(0,i.kt)("inlineCode",{parentName:"p"},"ISubscriber"),", for example here the ",(0,i.kt)("inlineCode",{parentName:"p"},"IHelloSubscriber")," which contains a set of functions for all the properties and signals for the notification mechanism."),(0,i.kt)("p",null,"The implementation for ",(0,i.kt)("inlineCode",{parentName:"p"},"IHello")," contains a publisher which can be used to subscribe for those changes called ",(0,i.kt)("inlineCode",{parentName:"p"},"IHelloSubscriber"),". Each time publisher will receive publish request it will notify all subscribed ",(0,i.kt)("inlineCode",{parentName:"p"},"IHelloSubscriber")," object about change.\nYou can use ",(0,i.kt)("inlineCode",{parentName:"p"},"IHelloSubscriber")," class to implement your local clients of the ",(0,i.kt)("inlineCode",{parentName:"p"},"IHello")," or a network service adapter - see ",(0,i.kt)("a",{parentName:"p",href:"/template-cpp14/features/olink#olink-server-adapter"},"Olink Server"),"."),(0,i.kt)("p",null,"Below is a small code snippet which shows an example implementation for ",(0,i.kt)("inlineCode",{parentName:"p"},"IHelloSubscriber"),", a class which main functionality is reacting on changes in ",(0,i.kt)("inlineCode",{parentName:"p"},"Hello"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"class HelloUser : public IHelloSubscriber\n{\npublic:\n    HelloUser(IHello& Hello)\n    : m_Hello(Hello)\n    {\n        m_Hello._getPublisher().subscribeToAllChanges(*this);\n    }\n     ~HelloUser()\n     {\n          m_Hello._getPublisher().unsubscribeFromAllChanges(*this);\n     }\n\n    void onJustSaid(const Message& /*msg*/) override\n    {\n        // do something with msg.\n    }\n\n    void onLastChanged(const Message& /*last*/) override\n    {\n        // do something with last;\n    }\n    // Some other functionality.\nprivate:\n    IHello& m_Hello\n}\n\n")),(0,i.kt)("h3",{id:"other"},"Other"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"\ud83d\udcdc CMakeLists.txt")," for building this module, describing it's dependencies, and exposing built package for other features that will use it. ",(0,i.kt)("br",null),"\n",(0,i.kt)("inlineCode",{parentName:"p"},"\ud83d\udcdc common.h")," prepares dll import/export statements."))}h.isMDXComponent=!0}}]);