"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[78],{2807:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>d,frontMatter:()=>l,metadata:()=>u,toc:()=>p});var a=n(7462),i=(n(7294),n(3905)),r=n(814),s=n(7784);const l={sidebar_position:1},o="API",u={unversionedId:"features/api",id:"features/api",title:"API",description:"The feature api is the bare minimum for the code generation. What you receive is:",source:"@site/docs/features/api.md",sourceDirName:"features",slug:"/features/api",permalink:"/template-cpp14/features/api",draft:!1,editUrl:"https://github.com/apigear-io/template-cpp14/edit/main/docs/features/api.md",tags:[],version:"current",lastUpdatedBy:"dphan10",lastUpdatedAt:1700746132,formattedLastUpdatedAt:"Nov 23, 2023",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"docsSidebar",previous:{title:"Features",permalink:"/template-cpp14/features/"},next:{title:"Stubs",permalink:"/template-cpp14/features/stubs"}},c={},p=[{value:"File overview for module",id:"file-overview-for-module",level:3},{value:"Enums and Structures",id:"enums-and-structures",level:3},{value:"Enums",id:"enums",level:4},{value:"Structs",id:"structs",level:4},{value:"Interfaces",id:"interfaces",level:3},{value:"Publisher",id:"publisher",level:4},{value:"Subscriber",id:"subscriber",level:4},{value:"Other",id:"other",level:3}],h={toc:p},m="wrapper";function d(e){let{components:t,...n}=e;return(0,i.kt)(m,(0,a.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"api"},"API"),(0,i.kt)("p",null,"The feature ",(0,i.kt)("inlineCode",{parentName:"p"},"api")," is the bare minimum for the code generation. What you receive is:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"basic API for your interfaces"),(0,i.kt)("li",{parentName:"ul"},"interfaces for ",(0,i.kt)("a",{parentName:"li",href:"api#publisher"},"publisher")," and ",(0,i.kt)("a",{parentName:"li",href:"api#subscriber"},"subscriber")," tailored for each interface"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("em",{parentName:"li"},"enums")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("em",{parentName:"li"},"structs")," with a basic implementation")),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"Check out the ",(0,i.kt)("a",{parentName:"p",href:"/template-cpp14/features/stubs"},"stubs")," feature which provides fully functional implementation for the publisher.")),(0,i.kt)("h3",{id:"file-overview-for-module"},"File overview for module"),(0,i.kt)("p",null,"With an example API"),(0,i.kt)("details",null,(0,i.kt)("summary",null,"Hello World API (click to expand)"),(0,i.kt)(r.Z,{language:"yaml",showLineNumbers:!0,mdxType:"CodeBlock"},s.Z)),(0,i.kt)("p",null,"the following file structure will be generated. The purpose and content of each file is explained below."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"\ud83d\udcc2hello-world\n \u2523 \ud83d\udcc2apigear\n \u2523 \ud83d\udcc2cpp_hello_world\n \u2503 \u2523 \ud83d\udcc2apigear\n \u2503 \u2523 \ud83d\udcc2examples\n \u2503 \u2523 \ud83d\udcc2modules\n \u2503 \u2503   \u2517 \ud83d\udcc2io_world_module\n \u2503 \u2503      \u2517 \ud83d\udcc2io_world\n \u2503 \u2503         \u2523 \ud83d\udcc2generated\n \u2503 \u2503         \u2503  \u2523 \ud83d\udcc2api\n \u2503 \u2503         \u2503  \u2503  \u2523 \ud83d\udcdcCMakeLists.txt\n \u2503 \u2503         \u2503  \u2503  \u2523 \ud83d\udcdccommon.h\n \u2503 \u2503         \u2503  \u2503  \u2523 \ud83d\udcdcdatastructs.api.cpp\n \u2503 \u2503         \u2503  \u2503  \u2523 \ud83d\udcdcdatastructs.api.h\n \u2503 \u2503         \u2503  \u2503  \u2523 \ud83d\udcdchello.api.h\n \u2503 \u2503         \u2503  \u2503  \u2517 \ud83d\udcdcio_world.h\n .. .\n")),(0,i.kt)("h3",{id:"enums-and-structures"},"Enums and Structures"),(0,i.kt)("p",null,"Files ",(0,i.kt)("inlineCode",{parentName:"p"},"datastructs.api.h")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"datastructs.api.cpp")," contain structures and enums used in your module:"),(0,i.kt)("h4",{id:"enums"},"Enums"),(0,i.kt)("p",null,"Enum classes.",(0,i.kt)("br",null),"\nFor convenience of use each enum has",(0,i.kt)("inlineCode",{parentName:"p"},"toEnum")," function, which converts given ",(0,i.kt)("inlineCode",{parentName:"p"},"uint8_t")," to enum value."),(0,i.kt)("h4",{id:"structs"},"Structs"),(0,i.kt)("p",null,"With all the fields public and initialized to default values.",(0,i.kt)("br",null),"\nFor convenience of use each structure has:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"equality comparison operators"),(0,i.kt)("li",{parentName:"ul"},"empty constructor and a constructor with parameters for all its fields.")),(0,i.kt)("h3",{id:"interfaces"},"Interfaces"),(0,i.kt)("p",null,"For each interface there is separate file generated, here the ",(0,i.kt)("inlineCode",{parentName:"p"},"\ud83d\udcdchello.api.h"),".",(0,i.kt)("br",null),"\nIt contains pure virtual class for your interface as well as pure virtual subscriber and publisher class.",(0,i.kt)("br",null)),(0,i.kt)("p",null,"The interface has:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"a pure virtual ",(0,i.kt)("inlineCode",{parentName:"li"},"getters")," and a ",(0,i.kt)("inlineCode",{parentName:"li"},"setters")," for each property")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"   virtual void setLast(const Message& last) = 0;\n   virtual const Message& getLast() const = 0;\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"pure virtual functions for each operation")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"virtual int say(const Message& msg, When::WhenEnum when) = 0;\n")),(0,i.kt)("p",null,"  and their asynchronous versions"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"virtual std::future<int> sayAsync(const Message& msg, WhenEnum when) = 0;\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"An access to a publisher. ",(0,i.kt)("br",null)," The interface does not contain signals defined in your interface, the signals feature is achieved with a subscriber/publisher mechanism. ",(0,i.kt)("br",null),"\nA class interested in notification on signal emission (and property changes) needs to use the publisher to subscribe for those events.\nThe important thing is that your implementation of the interface should notify the IHelloPublisher about emitted signals or state changed.",(0,i.kt)("br",null),"\nNotice the convention for the getter - we use an underscore - this function is added by the generator to your interface, which might already use that name.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"virtual IHelloPublisher& _getPublisher() const = 0;\n")),(0,i.kt)("h4",{id:"publisher"},"Publisher"),(0,i.kt)("p",null,"The IHelloPublisher provides the interface for subscribing and unsubscribing from a signal emission\nor a property change. Use of such class is mandatory for implementation, it is exposed in your API, to allow users of your API to react on changes.\nThe publisher responsibility is to keep its clients informed about requested changes, but it is the interface (here ",(0,i.kt)("inlineCode",{parentName:"p"},"IHello"),") implementation responsibility\nto call the publish functions from its API when signal or property change occurs e.g:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp",metastring:"IHello implementation",IHello:!0,implementation:!0},"void Hello::setLast(const Message& last)\n{\n    ...\n    m_publisher->publishLastChanged(last);\n\n}\n")),(0,i.kt)("p",null,"There are two ways of subscribing for changes. ",(0,i.kt)("br",null),"\nEither provide an implementation for ISubscriber interface class and use it with publisher with methods"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"virtual void subscribeToAllChanges(IHelloSubscriber& subscriber) = 0;\nvirtual void unsubscribeFromAllChanges(IHelloSubscriber& subscriber) = 0;\n")),(0,i.kt)("p",null,"which will assure that your the Subscriber will be informed about all emitted signals and all property changes. ",(0,i.kt)("br",null),"\nOr use the ",(0,i.kt)("em",{parentName:"p"},"parallel")," system of notification which doesn't require the ISubscriber and inform your Interface user about change of specific property or signal emission. E.g for LastChanged"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"virtual long subscribeToLastChanged(HelloLastPropertyCb callback) = 0;\nvirtual void unsubscribeFromLastChanged(long handleId) = 0;\n")),(0,i.kt)("p",null,"The publisher will execute provided callback function each time only this property is changed."),(0,i.kt)("admonition",{type:"caution"},(0,i.kt)("p",{parentName:"admonition"},"Make sure to remove subscription for a callback before it becomes invalid.\nAlso make sure that the subscribed function is not blocking and returns immediately!")),(0,i.kt)("p",null,"The publish functions need to be called by implementation of the IIHello on each property changed or signal emission to notify all the subscribers about this change."),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"Subscriptions systems are parallel - if you use both of them for single interface user i.e subscribe your class as an ISubscriber and for a single change\nyour subscriber will be informed twice about that change, one for each subscription mechanism.\nThis means that the unsubscribe functions for both mechanisms work only for that mechanism, i.e. the unsubscribe with ISubscriber will not remove any subscriptions for the specific property/signal and they stay intact.")),(0,i.kt)("h4",{id:"subscriber"},"Subscriber"),(0,i.kt)("p",null,"For each interface we generate the ",(0,i.kt)("inlineCode",{parentName:"p"},"ISubscriber"),", here the ",(0,i.kt)("inlineCode",{parentName:"p"},"IHelloSubscriber")," which contains set of functions for all the properties and signals for notification mechanism.\nThe implementation for IHello contains a publisher with which you can subscribe for those changes your IHelloSubscriber. Each time publisher will receive publish request it will notify all subscribed ",(0,i.kt)("inlineCode",{parentName:"p"},"IHelloSubscriber")," object about change.\nYou can use IHelloSubscriber class to implement your local clients of the IHello or a network service adapter - see ",(0,i.kt)("a",{parentName:"p",href:"/template-cpp14/features/olink#olink-server-adapter"},"Olink Server"),"."),(0,i.kt)("p",null,"Below small code snippet for shows example implementation for ",(0,i.kt)("inlineCode",{parentName:"p"},"IHelloSubscriber"),", a class which main functionality is reacting on changes in ",(0,i.kt)("inlineCode",{parentName:"p"},"Hello"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"class HelloUser : public IHelloSubscriber\n{\npublic:\n    HelloUser(IHello& Hello)\n    : m_Hello(Hello)\n    {\n        m_Hello._getPublisher().subscribeToAllChanges(*this);\n    }\n     ~HelloUser()\n     {\n          m_Hello._getPublisher().unsubscribeFromAllChanges(*this);\n     }\n\n    void onJustSaid(const Message& /*msg*/) override\n    {\n        // do something with msg.\n    }\n    \n    void onLastChanged(const Message& /*last*/) override\n    {\n        // do something with last;\n    }\n    // Some other functionality.\nprivate:\n    IHello& m_Hello\n}\n\n")),(0,i.kt)("h3",{id:"other"},"Other"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"\ud83d\udcdc CMakeLists.txt")," for building this module, describing it's dependencies, and exposing built package for other features that will use it. ",(0,i.kt)("br",null),"\n",(0,i.kt)("inlineCode",{parentName:"p"},"\ud83d\udcdc common.h")," prepares dll import/export statements."))}d.isMDXComponent=!0}}]);