"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[36],{7849:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>s,default:()=>u,frontMatter:()=>l,metadata:()=>p,toc:()=>c});var a=n(7462),i=(n(7294),n(3905)),o=n(814),r=n(7784);n.p;const l={sidebar_position:3},s="MQTT",p={unversionedId:"features/mqtt",id:"features/mqtt",title:"MQTT",description:"This is an experimental feature. It contains the smallest working set of functionalities to adapt the generated interface for use with the MQTT protocol.",source:"@site/docs/features/mqtt.md",sourceDirName:"features",slug:"/features/mqtt",permalink:"/template-cpp14/features/mqtt",draft:!1,editUrl:"https://github.com/apigear-io/template-cpp14/edit/main/docs/features/mqtt.md",tags:[],version:"current",lastUpdatedBy:"dphan10",lastUpdatedAt:1706261464,formattedLastUpdatedAt:"Jan 26, 2024",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"docsSidebar",previous:{title:"Stubs",permalink:"/template-cpp14/features/stubs"},next:{title:"Olink",permalink:"/template-cpp14/features/olink"}},d={},c=[{value:"File overview for module",id:"file-overview-for-module",level:2},{value:"ApiGear MQTT - The Network Layer",id:"apigear-mqtt---the-network-layer",level:3},{value:"MQTT Client Adapter",id:"mqtt-client-adapter",level:3},{value:"Properties",id:"properties",level:4},{value:"Operations",id:"operations",level:4},{value:"Signals",id:"signals",level:4},{value:"Use <code>HelloClient</code>",id:"use-helloclient",level:4},{value:"MQTT Server Adapter",id:"mqtt-server-adapter",level:3},{value:"Properties",id:"properties-1",level:4},{value:"Operations",id:"operations-1",level:4},{value:"Signals",id:"signals-1",level:4},{value:"Use <code>HelloService</code>",id:"use-helloservice",level:4},{value:"MQTT Messages",id:"mqtt-messages",level:3}],m={toc:c},h="wrapper";function u(e){let{components:t,...l}=e;return(0,i.kt)(h,(0,a.Z)({},m,l,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"mqtt"},"MQTT"),(0,i.kt)("admonition",{type:"caution"},(0,i.kt)("p",{parentName:"admonition"},"This is an experimental feature. It contains the smallest working set of functionalities to adapt the generated interface for use with the MQTT protocol.\nIt doesn't include any security, the error handling is minimal and it is not production ready. Please also check issues on github for this template.")),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"A ",(0,i.kt)("a",{parentName:"p",href:"https://eclipse.dev/paho/index.php?page=clients/python/index.php"},"PAHO")," library is used to implement MQTT in this library. It seems to have significant performance limitations for high load."),(0,i.kt)("p",{parentName:"admonition"},"If you need to use MQTT in high load application consider using our qt template - currently seems to be working much better.")),(0,i.kt)("p",null,"This feature does not only introduce MQTT protocol into your project, but also show that an existing protocol can be adapted for sharing your data in your ecosystem. When going through this document you may notice this implementation contains general client/server adapters in ",(0,i.kt)("inlineCode",{parentName:"p"},"\ud83d\udcc2hello-world/apigear/mqtt"),"\nand an interface specific part generated from templates for each interface in ",(0,i.kt)("inlineCode",{parentName:"p"},"\ud83d\udcc2hello-world/cpp_hello_world/modules/io_world_module/generated/mqtt"),"."),(0,i.kt)("p",null,"This feature provides a ",(0,i.kt)("em",{parentName:"p"},"client")," and ",(0,i.kt)("em",{parentName:"p"},"service")," adapter for your interfaces for the MQTT protocol. It allows you to connect different applications in the same or different technologies (check all of our ",(0,i.kt)("a",{parentName:"p",href:"https://docs.apigear.io/docs/category/sdk-templates"},"templates"),")."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Use an ",(0,i.kt)("em",{parentName:"li"},"Mqtt client")," instead of your interface implementation to be able to receive data from remote service."),(0,i.kt)("li",{parentName:"ul"},"Use an ",(0,i.kt)("em",{parentName:"li"},"Mqtt server adapter")," to expose your interface implementation as a remote service.")),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"The MQTT broker is not provided with the template. To be able to run client and service you need to run a broker of your choice, which is accessible for both client and service.")),(0,i.kt)("admonition",{type:"caution"},(0,i.kt)("p",{parentName:"admonition"},"In this library we use STL classes in public interfaces.\nWe assume that this library is built from source (configuration provided by generated ",(0,i.kt)("inlineCode",{parentName:"p"},"CMakeLists"),").\nOtherwise, it has to be ensured that your build configuration matches the library build configuration.")),(0,i.kt)("h2",{id:"file-overview-for-module"},"File overview for module"),(0,i.kt)("p",null,"With our API definition"),(0,i.kt)("details",null,(0,i.kt)("summary",null,"Hello World API (click to expand)"),(0,i.kt)(o.Z,{language:"yaml",showLineNumbers:!0,mdxType:"CodeBlock"},r.Z)),(0,i.kt)("p",null,"the following file structure is generated. The purpose and content of each file is explained below."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash",metastring:"{6,21}","{6,21}":!0},"\ud83d\udcc2hello-world\n \u2523 \ud83d\udcc2apigear\n \u2503 ...\n \u2523 \ud83d\udcc2cpp_hello_world\n \u2503 \u2523 \ud83d\udcc2apigear\n \u2503 \u2503 \u2523 \ud83d\udcc2mqtt\n \u2503 \u2503 \u2503 \u2523 \ud83d\udcdcCMakeLists.txt\n \u2503 \u2503 \u2503 \u2523 \ud83d\udcdcmqttclient.cpp\n \u2503 \u2503 \u2503 \u2523 \ud83d\udcdcmqttclient.h\n \u2503 \u2503 \u2503 \u2523 \ud83d\udcdcmqttservice.cpp\n \u2503 \u2503 \u2503 \u2523 \ud83d\udcdcmqttservice.h\n \u2503 \u2503 \u2503 \u2523 ... (helper files)\n \u2503 \u2503 ...\n \u2503 \u2523 \ud83d\udcc2examples\n \u2503 \u2523 \ud83d\udcc2modules\n \u2503 \u2503   \u2517 \ud83d\udcc2io_world_module\n \u2503 \u2503      \u2517 \ud83d\udcc2io_world\n \u2503 \u2503         \u2523 \ud83d\udcc2generated\n \u2503 \u2503         \u2503  \u2523 \ud83d\udcc2api\n \u2503 \u2503         \u2503  \u2523 \ud83d\udcc2core\n \u2503 \u2503         \u2503  \u2523 \ud83d\udcc2mqtt\n \u2503 \u2503         \u2503  \u2503 \u2523 \ud83d\udcdcCMakeLists.txt\n \u2503 \u2503         \u2503  \u2503 \u2523 \ud83d\udcdchelloclient.cpp\n \u2503 \u2503         \u2503  \u2503 \u2523 \ud83d\udcdchelloclient.h\n \u2503 \u2503         \u2503  \u2503 \u2523 \ud83d\udcdchelloservice.cpp\n \u2503 \u2503         \u2503  \u2503 \u2517 \ud83d\udcdchelloservice.h\n ...\n")),(0,i.kt)("h3",{id:"apigear-mqtt---the-network-layer"},"ApiGear MQTT - The Network Layer"),(0,i.kt)("p",null,"When using the ",(0,i.kt)("inlineCode",{parentName:"p"},"mqtt")," feature (or any of those: ",(0,i.kt)("inlineCode",{parentName:"p"},"olink"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"monitor")," feature) you'll get an additional folder at the top most directory: the ",(0,i.kt)("inlineCode",{parentName:"p"},"\ud83d\udcc2hello-world/cpp_hello_world/apigear"),". The ",(0,i.kt)("inlineCode",{parentName:"p"},"\ud83d\udcc2mqtt")," subfolder contains objects that implement a network layer (based on ",(0,i.kt)("a",{parentName:"p",href:"https://eclipse.dev/paho/index.php?page=clients/python/index.php"},"PAHO")," library) for the MQTT protocol. Those are:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"Client")," - Adapts the MQTT client, to serve as an network endpoint for ",(0,i.kt)("a",{parentName:"p",href:"mqtt#mqtt-client-adapter"},"interface client adapters"),".\nExposes:"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"methods that allow receiving data from remote service: subscribing for properties changes, signals emission and method response invocation;")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"methods that allow remote using the service: requesting property change or invoking a method."),(0,i.kt)("p",{parentName:"li"},"The client may serve many client interface adapters, even for the same interfaces (allows subscribing for same topic).\nIn case many interface client adapters for same interface are connected: property changes and signals are provided to all the interface client adapters, but the invoke method response will be delivered only for the one that requested it.")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"ServiceAdapter")," - Adapts the MQTT client to serve as an network endpoint for ",(0,i.kt)("a",{parentName:"p",href:"mqtt#mqtt-server-adapter"},"interface service adapters"),".\nExposes:"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"methods that allow receiving requests from remote clients: subscribing for properties change requests, send method invocation;")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"methods that allow publishing property change, signal, functionality to handles sending a response for method invocation requests."),(0,i.kt)("p",{parentName:"li"},"This ",(0,i.kt)("inlineCode",{parentName:"p"},"ServiceAdapter")," may be used for many interface service adapters, but it is not recommended to use more than one interface service adapter for same interface."))))),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"Have in mind that MQTT might not be suitable for high-frequency messages especially with one mqtt client serving more than one object.\nAlso the brokers have limits for messages number/size queued from one client. In case you are not getting all the messages consider changing those or splitting traffic between more clients (maybe some handle the properties, some handle the methods).")),(0,i.kt)("h3",{id:"mqtt-client-adapter"},"MQTT Client Adapter"),(0,i.kt)("p",null,"Files ",(0,i.kt)("inlineCode",{parentName:"p"},"\ud83d\udcdchelloclient.h")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"\ud83d\udcdchelloclient.cpp")," implement the remote client for the ",(0,i.kt)("inlineCode",{parentName:"p"},"Hello")," interface - a ",(0,i.kt)("inlineCode",{parentName:"p"},"HelloClient")," class.",(0,i.kt)("br",null),"\nThe object is an ",(0,i.kt)("inlineCode",{parentName:"p"},"IHello")," implementation.",(0,i.kt)("br",null),"\nIt requires an instance of Apigear::Mqtt::Client to work. It uses the Client to subscribe (and unsubscribe) for topics that allow receiving properties, signals and invoke responses from service."),(0,i.kt)("h4",{id:"properties"},"Properties"),(0,i.kt)("p",null,"The property getters (here ",(0,i.kt)("inlineCode",{parentName:"p"},"getLast()")," ) return immediately the locally stored,last received value from service. ",(0,i.kt)("br",null),"\nThe property setter (here ",(0,i.kt)("inlineCode",{parentName:"p"},"void setLast(const Message& last)")," ) requests setting a value on service side, local value is not changed. ",(0,i.kt)("br",null),"\nYou can subscribe to a property change event (here ",(0,i.kt)("inlineCode",{parentName:"p"},"last")," property ) through the publisher which you can get from the API with ",(0,i.kt)("inlineCode",{parentName:"p"},"_getPublisher()"),".\nOr you can subscribe as an ",(0,i.kt)("inlineCode",{parentName:"p"},"IHelloSubscriber")," and get all changes. See ",(0,i.kt)("a",{parentName:"p",href:"/template-cpp14/features/api#publisher"},"publisher")," and ",(0,i.kt)("a",{parentName:"p",href:"/template-cpp14/features/api#subscriber"},"subscriber")," for more info on subscribing.\nWhen the client receives information that server changed the property, a target property (here ",(0,i.kt)("inlineCode",{parentName:"p"},"last"),") is updated locally and a notifies subscribers that property has changed."),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"The connected interface client adapter has its local properties in sync with a service. The messages with property changes are retained in MQTT broker, so all properties which are already set are provided.")),(0,i.kt)("h4",{id:"operations"},"Operations"),(0,i.kt)("p",null,"The operations have an async version, which is called by the immediate version."),(0,i.kt)("p",null,"The async version sends an invoke operation request to a server."),(0,i.kt)("p",null,"So calling ",(0,i.kt)("inlineCode",{parentName:"p"},"myHelloClientInstance.say(myWhen)")," implements execution of ",(0,i.kt)("inlineCode",{parentName:"p"},"sayAsync")," and waits for the result (for non-void type of operations). Have in mind that this is a blocking operation."),(0,i.kt)("h4",{id:"signals"},"Signals"),(0,i.kt)("p",null,"You should not emit any signals from a client."),(0,i.kt)("p",null,"You can subscribe to any signals offered by your interface (here ",(0,i.kt)("inlineCode",{parentName:"p"},"justSaid)")," signal), through the publisher. You can either select the signal you're interested in, or subscribe as an ",(0,i.kt)("inlineCode",{parentName:"p"},"IHelloSubscriber")," to get all the signals and property change notifications."),(0,i.kt)("p",null,"When a ",(0,i.kt)("inlineCode",{parentName:"p"},"HelloClient")," client receives the message from server that indicates the signal was emitted it notifies all the subscribers that requested this notification.."),(0,i.kt)("h4",{id:"use-helloclient"},"Use ",(0,i.kt)("inlineCode",{parentName:"h4"},"HelloClient")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"HelloClient")," is an adapter of Mqtt (with protocol and network layer implementation), here provided by a ",(0,i.kt)("inlineCode",{parentName:"p"},"ApiGear::MQTT::Client"),".\nAll you need to do is to pass the ",(0,i.kt)("inlineCode",{parentName:"p"},"ApiGear::MQTT::Client")," to your Interface Client Adapter, and request connecting to host when it is convenient for you."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'// Create a client and make a connection\nauto mqttclient = std::make_shared<ApiGear::MQTT::Client>("UniqueClientName");\n\n// set up modules\nauto ioWorldHello = std::make_unique<IoWorld::MQTT::HelloClient>(mqttclient);\n\n// start mqtt connection\nmqttclient.connectToHost("tcp://localhost:1883"); // Use the same port number as your broker is using. Typically, without any other settings it is "1883".\n\n// use your ioWorldHello as it was Hello implementation\nioWorldHello->say(IoWorld::WhenEnum::Soon);\nauto lastMessage = ioWorldHello->getLast();\nIoWorld::Message someMessage("the new content");\nioWorldHello->setLast(someMessage);\ntestIoWorldHello->_getPublisher().subscribeToJustSaid([](auto args) { /*handle the signal*/});\n')),(0,i.kt)("h3",{id:"mqtt-server-adapter"},"MQTT Server Adapter"),(0,i.kt)("p",null,"The files ",(0,i.kt)("inlineCode",{parentName:"p"},"\ud83d\udcdchelloservice.h")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"\ud83d\udcdchelloservice.cpp")," contain the MQTT service side adapter for the ",(0,i.kt)("inlineCode",{parentName:"p"},"Hello")," interface - the ",(0,i.kt)("inlineCode",{parentName:"p"},"HelloService")," class. It uses the general MQTT service adapter ",(0,i.kt)("inlineCode",{parentName:"p"},"ApiGear::MQTT::Service"),"."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"HelloService")," object exposes the local object for remote usage with the MQTT protocol. It handles all the network requests, and calls on your local object.\nThe client connections and communication with them is handled transparently for you, no additional actions are needed."),(0,i.kt)("h4",{id:"properties-1"},"Properties"),(0,i.kt)("p",null,"Each time a property of your the ",(0,i.kt)("inlineCode",{parentName:"p"},"Hello")," interface implementation changes, a message is sent to all connected clients with information, which property changed to which value. It is true for both - local calls on the ",(0,i.kt)("inlineCode",{parentName:"p"},"Hello")," object, by other local ",(0,i.kt)("inlineCode",{parentName:"p"},"Hello")," users or when a change property request message is received by this ",(0,i.kt)("inlineCode",{parentName:"p"},"HelloService")," (the ",(0,i.kt)("inlineCode",{parentName:"p"},"HelloService")," applies the property on your local ",(0,i.kt)("inlineCode",{parentName:"p"},"Hello")," object and then the ",(0,i.kt)("inlineCode",{parentName:"p"},"HelloService")," is triggered)."),(0,i.kt)("h4",{id:"operations-1"},"Operations"),(0,i.kt)("p",null,"The operations invocation which was triggered from the clients through the network will be performed on your local ",(0,i.kt)("inlineCode",{parentName:"p"},"Hello")," object. The result of the operation (if any) will be returned only to the client, from which the message was send, not all clients."),(0,i.kt)("h4",{id:"signals-1"},"Signals"),(0,i.kt)("p",null,"All the signals emitted by your local ",(0,i.kt)("inlineCode",{parentName:"p"},"Hello")," objects are forwarded as an MQTT message to all connected clients."),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"Have in mind that the ",(0,i.kt)("inlineCode",{parentName:"p"},"Hello")," implementation is not thread safe by default.")),(0,i.kt)("h4",{id:"use-helloservice"},"Use ",(0,i.kt)("inlineCode",{parentName:"h4"},"HelloService")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"HelloService")," is an adapter of Mqtt (with protocol and network layer implementation), here provided by a ",(0,i.kt)("inlineCode",{parentName:"p"},"ApiGear::MQTT::ServiceAdapter"),"\nAll you need to do is to pass the ",(0,i.kt)("inlineCode",{parentName:"p"},"ApiGear::MQTT::ServiceAdapter")," and a local Hello implementation to your HelloService Adapter, then request connecting to host whenever convenient for you."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'auto mqttservice = std::make_shared<ApiGear::MQTT::Service>("ServiceUniqueNameInMqtt");\nauto ioWorldHello = std::make_shared<IoWorld::Hello>();\nIoWorld::MQTT::HelloService mqttHelloService(ioWorldHello, mqttservice);\n\n// start mqtt connection\nmqttservice->connectToHost("tcp://localhost:1883");\n\n// use your ioWorldHello as it was Hello implementation, all property changes, and signals will be passed to connected MqttHello clients.\nioWorldHello->say(IoWorld::WhenEnum::Soon);\nIoWorld::Message someMessage("the new content");\nauto lastMessage = ioWorldHello->getLast();\nioWorldHello->setLast(someMessage); // after this call - if new property is different than current one - all clients will be informed about new value.\ntestIoWorldHello->_getPublisher().publishJustSaid(someMessage);\n')),(0,i.kt)("h3",{id:"mqtt-messages"},"MQTT Messages"),(0,i.kt)("p",null,"In case you want construct messages for client or server side on your own, please check how topics are created and how does the payload look like, check this document ",(0,i.kt)("a",{target:"_blank",href:n(5753).Z},"messages format"),"."))}u.isMDXComponent=!0},5753:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/files/ApiGearMQTTv0.1-2a3f7ef573c506e85e1be8ce33178064.pdf"}}]);