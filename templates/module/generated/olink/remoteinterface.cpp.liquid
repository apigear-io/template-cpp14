{% comment %} // Copyright (c) ApiGear UG 2020 {% endcomment -%}
{{ module | licGPLcpp -}}
{% assign class = interface.name |prepend:"Remote"-%}
{% assign pub_class = interface.name | capital | append: "Publisher" %}
{% assign pub_interface = "I" | append: interface.name | capital | append: "Publisher"%}
{% assign identifiername = module.name | append: "." | append: interface.name %}


#include "{{module.name|identifier}}/generated/olink/remote{{interface.name|lower}}.h"
#include "{{module.name|identifier}}/generated/core/{{interface.name|lower}}.publisher.h"
#include "{{module.name|identifier}}/generated/core/{{module.name|identifier}}.json.adapter.h"

using namespace {{ system.name | capital }}::{{ module.name | capital }};
using namespace {{ system.name | capital }}::{{ module.name | capital }}::olink;

{{class}}::{{class}}(ApiGear::ObjectLink::ClientRegistry& registry, ApiGear::PocoImpl::OLinkClient& client)
    : m_registry(registry),
    m_publisher(std::make_unique<{{pub_class}}>())
{
    m_registry.addObjectSink(this);
    client.linkObjectSource("{{identifiername}}");
}

{{class}}::~{{class}}()
{
    m_registry.removeObjectSink(this);
}

void {{class}}::applyState(const nlohmann::json& fields) 
{
{% for property in interface.properties %}
    if(fields.contains("{{property.name}}")) {
        set{{property.name|capital}}Local(fields["{{property.name}}"].get<{{property | cpp14Return}}>());
    }
{% else %}
    // no properties to apply state {% comment %} we generate anyway for consistency {% endcomment %}
    (void) fields;
{% endfor %}
}

{% for property in interface.properties %}
{% assign name = property.name %}

void {{class}}::set{{name|capital}}({{property|cpp14Param}})
{
    if(m_node == nullptr) {
        return;
    }
    m_node->setRemoteProperty("{{module}}.{{interface}}/{{property}}", {{property}});
}

void {{class}}::set{{name|capital}}Local({{property|cpp14Param}})
{
    if (m_data.m_{{name}} != {{name}}) {
        m_data.m_{{name}} = {{name}};
        m_publisher->publish{{name | capital}}Changed({{name}});
    }
}

{{property|cpp14Return: true}} {{class}}::{{name}}() const
{
    return m_data.m_{{name}};
}

{% endfor %}


{% for operation in interface.operations %}
{% capture returnType %}{{operation|cpp14Return}}{% endcapture %}

{{returnType}} {{class}}::{{operation.name}}({{operation|cpp14Params}})
{
    if(m_node == nullptr) {
        return {{operation|cpp14Default}};
    }
    {% if operation.type == 'void' %}
    ApiGear::ObjectLink::InvokeReplyFunc func = [this](ApiGear::ObjectLink::InvokeReplyArg arg)
        {
            (void) this;
            (void) arg;
        };
    const nlohmann::json &args = nlohmann::json::array({
        {{ operation.params | map: 'name' | join: ', ' }}
    });
    m_node->invokeRemote("{{module.name|identifier}}.{{interface}}/{{operation}}", args, func);
    {% else %}
    {{returnType}} value({{operation.name}}Async({{ operation.params | map: 'name' | join: ', ' }}).get());
    return value;
    {% endif %}
}

std::future<{{returnType}}> {{class}}::{{operation.name}}Async({{operation|cpp14Params}})
{
    if(m_node == nullptr) {
        throw std::runtime_error("Node is not initialized");
    }
    return std::async(std::launch::async, [this{%- for param in operation.params -%},
                    {{param}}
                {%- endfor -%}]()
        {
            std::promise<{{returnType}}> resultPromise;
            m_node->invokeRemote("{{module}}.{{interface}}/{{operation}}",
                nlohmann::json::array({
                {%- for param in operation.params -%}
                    {{param}}{% unless forloop.last %},{% endunless -%}
                {%- endfor -%}}), [&resultPromise](ApiGear::ObjectLink::InvokeReplyArg arg) {        
                    {% if operation.type == 'void' %}
                    (void) arg;
                    resultPromise.set_value();
                    {% else %}
                    const {{returnType}}& value = arg.value.get<{{returnType}}>();
                    resultPromise.set_value(value);
                    {% endif %}
                });
            return resultPromise.get_future().get();
        }
    );
}

{% endfor %}

std::string {{class}}::olinkObjectName()
{
    return "{{identifiername}}";
}

void {{class}}::olinkOnSignal(std::string name, nlohmann::json args)
{
    std::string path = ApiGear::ObjectLink::Name::pathFromName(name);
{% for signal in interface.signals %}
    if(path == "{{signal}}") {
        m_publisher->publish{{signal.name | capital}}(
{%- for param in signal.params -%}
        args[{{forloop.index0}}].get<{{param|cpp14Return}}>(){% unless forloop.last %},{% endunless -%}
{%- endfor -%}
        );   
        return;
    }
{% else %}
    (void) args;
{% endfor %}
}

void {{class}}::olinkOnPropertyChanged(std::string name, nlohmann::json value)
{
    std::string path = ApiGear::ObjectLink::Name::pathFromName(name);
    applyState({ {path, value} });
}
void {{class}}::olinkOnInit(std::string name, nlohmann::json props, ApiGear::ObjectLink::IClientNode *node)
{
    (void) name; //suppress the 'Unreferenced Formal Parameter' warning.
    m_node = node;
    applyState(props);
}

void {{class}}::olinkOnRelease()
{
    m_node = nullptr;
}

bool {{class}}::isReady() const
{
    return m_node != nullptr;
}

{{pub_interface}}& {{class}}::_getPublisher() const
{
    return *m_publisher;
}
