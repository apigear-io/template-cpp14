{% comment %} // Copyright (c) ApiGear UG 2020 {% endcomment -%}
{{ module | licGPLcpp }}
{% assign class = interface.name | capital | append: "TraceDecorator" -%}
{% assign interface_class = "I" | append: interface.name | capital %}
{% assign sub_class = "I" | append: interface.name | capital | append: "Subscriber" %}
{% assign pub_class = "I" | append: interface.name | capital |  append: "Publisher"%}

#include "{{module.name|identifier}}/generated/monitor/{{interface.name|lower}}.tracedecorator.h"
#include "{{module.name|identifier}}/generated/monitor/{{interface.name|lower}}.tracer.h"

using namespace {{ system.name | capital }}::{{ module.name | capital }};
{{class}}::{{class}}({{interface_class}}& impl, ApiGear::PocoImpl::Tracer& tracer)
    : m_tracer(std::make_unique<{{interface.name}}Tracer>(tracer))
    , m_impl(impl)
{
{% for signal in interface.signals %}
    m_{{signal.name}}SubscriptionToken = m_impl._getPublisher().subscribeTo{{signal.name | capital}}(
    [this]({%- for param in signal.params -%} {{param|cpp14Param: true}}{% unless forloop.last %},{% endunless -%}{%- endfor -%})
    {
        m_tracer->trace_{{signal.name | capital}}(
        {% for param in signal.params -%}
            {{param.name}}{% unless forloop.last %},{% endunless -%}
        {% endfor -%});
    }
    );
{% endfor %}
}
{{class}}::~{{class}}()
{
{% for signal in interface.signals %}
    m_impl._getPublisher().unsubscribeFrom{{signal.name | capital}}(m_{{signal.name}}SubscriptionToken);
{% endfor %}
}

std::unique_ptr<{{class}}> {{class}}::connect({{interface_class}}& impl, ApiGear::PocoImpl::Tracer& tracer)
{
    return std::unique_ptr<{{class}}>(new {{class}}(impl, tracer));
}

{% for operation in interface.operations %}


{% if operation.description != "" %}
/**
   \brief {{operation.description}}
*/
{% endif %}
{{operation|cpp14Return}} {{class}}::{{operation.name}}({{operation|cpp14Params}})
{
    m_tracer->trace_{{operation.name}}({% for param in operation.params %}{{param.name}}{% unless forloop.last %},{% endunless %}{% endfor %});
    return m_impl.{{operation.name}}({% for param in operation.params %}{{param.name}}{% unless forloop.last %},{% endunless %}{% endfor %});
}

{% capture returnType %}{{operation|cpp14Return}}{% endcapture %}
std::future<{{returnType}}> {{class}}::{{operation.name}}Async({{operation|cpp14Params}})
{
    m_tracer->trace_{{operation.name}}({% for param in operation.params %}{{param.name}}{% unless forloop.last %},{% endunless %}{% endfor %});
    return m_impl.{{operation.name}}Async({% for param in operation.params %}{{param.name}}{% unless forloop.last %},{% endunless %}{% endfor %});
}

{% endfor %}

{% for property in interface.properties %}
void {{class}}::set{{property.name|capital}}({{property|cpp14Param}})
{
    m_tracer->capture_state(this);
    m_impl.set{{property.name|capital}}({{property.name}});
    m_impl.set{{property.name|capital}}({{property.name}});
}

{{property|cpp14Return: true}} {{class}}::{{property.name}}() const
{
    return m_impl.{{property.name}}();
}

{% endfor %}

{{pub_class}}& {{class}}::_getPublisher() const
{
    return m_impl._getPublisher();
}