{% comment %} // Copyright (c) ApiGear UG 2020 {% endcomment -%}
{{ module | licGPLcpp -}}
{% assign class = interface.name | capital -%}
{% assign interface_class = "I" | append: interface.name | capital %}
{% assign sub_class = "I" | append: interface.name | capital | append: "Subscriber" %}
{% assign pub_interface = "I" | append: interface.name | capital | append: "Publisher"%}
#pragma once
#include "{{module.name|identifier}}/generated/api/{{module.name|identifier}}.h"
#include "{{module.name|identifier}}/generated/api/common.h"
#include <memory>

namespace {{ system.name | capital }} {
namespace {{ module.name | capital }} {

/**
* The {{interface.name}} implementation. 
{% if interface.description != "" %}
*{{interface.description}}
{% endif %}
*/
class {{ system.name | constant }}_{{ module.name | constant }}_EXPORT {{class}} : public {{interface_class}}
{
public:
    explicit {{class}}();
    ~{{class}}();
public:
{% for property in interface.properties %}
    {% if property.description != undefined %}
    /**
    * {{property.name}} {{property.description}}
    */
{% endif %}
    void set{{property.name|capitalize}}({{ property|cpp14Param }}) override;
    {{property|cpp14Return: true}} {{property.name}}() const override;
    {{nl}}    
{% endfor %}

{% for operation in interface.operations %}
{% if operation.description != "" %}
    /**
    * {{operation.description}}
    */
{% endif %}
    {{operation|cpp14Return}} {{operation.name}}({{operation|cpp14Params}}) override;
    std::future<{{operation|cpp14Return}}> {{operation.name}}Async({{operation|cpp14Params}}) override;
        {{nl}} 
{% endfor %}

    /**
    * Access to a publisher, use it to subscribe for {{interface.name}} changes and signal emission.
    * @return The publisher for {{interface.name}}.
    */
    {{pub_interface}}& _getPublisher() const override;
private:
    /* The publisher for the {{interface.name}}. */
    std::unique_ptr<{{pub_interface}}> m_publisher;
    /**The helper structure to store all the properties for {{interface.name}}. */
    struct {{interface.name | capital}}Data;
    std::unique_ptr<{{interface.name | capital}}Data> m_data;
};
} // namespace {{ module.name | capital }}
} // namespace {{ system.name | capital }}
